<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Art Bot 3 v0.4</title>
</head>
<body onload="LoadGL();">
        <script src="seedrandom.js"></script>
    <script type="text/javascript">

        var requestNew = 0;
        var showFunc = null;

Array.prototype.random = function() {
    return this[Math.floor(Math.random()*this.length)];
}

String.prototype.hashCode = function() {
  var hash = 0, i, chr;
  if (this.length === 0) return hash;
  for (i = 0; i < this.length; i++) {
    chr   = this.charCodeAt(i);
    hash  = ((hash << 5) - hash) + chr;
    hash |= 0; // Convert to 32bit integer
  }
  return hash;
};

var grammar = {
    //'expr': function() { return ['Math.cos(expr)','Math.sin(expr)','expr-expr','expr*expr','expr+expr','expr%expr','Math.abs(expr)','Math.sqrt(expr)','Math.floor(expr)','Math.ceil(expr)','Math.max(expr,expr)','Math.min(expr,expr)','Math.atan2(expr,expr)','sigmoid(expr)','sigmoidd(expr)','Math.pow(expr,expr)','Math.exp(expr)', 'PerlinNoise.noise(expr,expr,expr)', 'Dist(expr,expr,expr,expr)', 'Sign(expr)'].random(); },
    'expr': function() { return ['expr+expr', 'expr-expr', 'expr*expr', 'radians(expr)', 'degrees(expr)', 'sin(expr)', 'cos(expr)', 'tan(expr)', 'asin(expr)', 'acos(expr)', 'atan(expr,expr)', 'atan(expr)', 'pow(expr,expr)', 'exp(expr)', 'log(expr)', 'exp2(expr)', 'log2(expr)', 'sqrt(expr)', 'inversesqrt(expr)', 'abs(expr)', 'floor(expr)', 'ceil(expr)', 'mod(expr,expr)', 'min(expr,expr)', 'max(expr,expr)', 'clamp(expr,expr,expr)', 'mix(expr,expr,expr)', 'step(expr,expr)', 'smoothstep(expr,expr,expr)', 'length(vec2(expr,expr))', 'distance(vec2(expr,expr),vec2(expr,expr))', 'dot(vec2(expr,expr),vec2(expr,expr))', 'sdSphere(vec3(expr,expr,expr),expr)', 'sdBox(vec3(expr,expr,expr),expr)'].random(); },
    'number': function() { return (10*Math.random()).toFixed(2) },
    'var': function() { 
        var result = ['x','y','t'].random(); 
        if(result == 't')
        {
            usingT = true;
        }
        return result;
    }
};

var complexity = 140;

function findGetParameter(parameterName) {
    var result = null,
        tmp = [];
    location.search
        .substr(1)
        .split("&")
        .forEach(function (item) {
          tmp = item.split("=");
          if (tmp[0] === parameterName) result = tmp[1];
        });
    return result;
}

var genExpr = function() {
    var str = 'expr';
    var len = complexity;
    var iters = 0;
    while(str.length < len && iters < 50) {
        str = str.replace(/(expr)|(number)|(var)/g, function(repl) {
            return grammar[repl]();
        });
        iters++;
    }
    str = str.replace(/(expr)|(number)|(var)/g, function(repl) {
        if(Math.random() > 0.5) {
            return grammar['var']();
        } else {
            return grammar['number']();
        }
    });
    return str;
}

function shaderProgram(gl, vs, fs) {
	var prog = gl.createProgram();
	var addshader = function(type, source) {
		var s = gl.createShader((type == 'vertex') ?
			gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
		gl.shaderSource(s, source);
		gl.compileShader(s);
		if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
			throw "Could not compile "+type+
				" shader:\n\n"+gl.getShaderInfoLog(s);
		}
		gl.attachShader(prog, s);
	};
	addshader('vertex', vs);
	addshader('fragment', fs);
	gl.linkProgram(prog);
	if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
		throw "Could not link the shader program!";
	}
	return prog;
}

function attributeSetFloats(gl, prog, attr_name, rsize, arr) {
	gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arr),
		gl.STATIC_DRAW);
	var attr = gl.getAttribLocation(prog, attr_name);
	gl.enableVertexAttribArray(attr);
	gl.vertexAttribPointer(attr, rsize, gl.FLOAT, false, 0, 0);
}

function loadTexture(gl, url) {
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);

  // Because images have to be download over the internet
  // they might take a moment until they are ready.
  // Until then put a single pixel in the texture so we can
  // use it immediately. When the image has finished downloading
  // we'll update the texture with the contents of the image.
  const level = 0;
  const internalFormat = gl.RGBA;
  const width = 1;
  const height = 1;
  const border = 0;
  const srcFormat = gl.RGBA;
  const srcType = gl.UNSIGNED_BYTE;
  const pixel = new Uint8Array([0, 0, 255, 255]);  // opaque blue
  gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                width, height, border, srcFormat, srcType,
                pixel);

  const image = new Image();
  image.onload = function() {
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                  srcFormat, srcType, image);

    // WebGL1 has different requirements for power of 2 images
    // vs non power of 2 images so check if the image is a
    // power of 2 in both dimensions.
    //if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
       // Yes, it's a power of 2. Generate mips.
    //   gl.generateMipmap(gl.TEXTURE_2D);
    //} else {
       // No, it's not a power of 2. Turn off mips and set
       // wrapping to clamp to edge
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    //}
  };
  image.src = url;

  return texture;
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

var gl = null;

var xLocc = null;
var yLocc = null;
var tLocc = null;
var zoomLocc = null;

var t = 0;
var xOffset = 0;
var yOffset = 0;
var xDelta = 0;
var yDelta = 0;
var zoom = 1;

function LoadGL()
{
    document.getElementById("urlText").value = "";

    try {
		gl = document.getElementById("webgl")
			.getContext("experimental-webgl");
		if (!gl) { throw "x"; }
	} catch (err) {
		throw "Your web browser does not support WebGL!";
	}
}

function RegenShaders(shaderText=null)
{
    var vertexShader = "attribute vec3 pos;"+
		"void main() {"+
		"	gl_Position = vec4(pos, 1.0);"+
        "}"

    if (shaderText == null) {
        // if we aren't loading with the Load button check the get param
        if (showFunc == null) {
            showFunc = findGetParameter("equation")
        }

        // clicks on New button should always generate a new one
        // else we didn't click Load or have a get param
        if (showFunc == null || requestNew == 1) {
            requestNew = 0;
            showFunc = genExpr();
        }
    }
    else
        showFunc = shaderText
        

    document.getElementById("showfunc").value = showFunc;
    equationText = showFunc;

    LoadPalette();

    var fragmentShader = "precision highp float;" +
        "uniform float t;" +
        "uniform float xOffset;" +
        "uniform float yOffset;" +
        "uniform float zoom;" +
        "uniform sampler2D uSampler;"+
        "float sdBox(in vec3 p, in float b)" +
        "{" +
        "   vec3 d = abs(p) - b;" +
        "   return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);" +
        "}" +
        "float sdSphere(in vec3 p, in float r)" +
        "{" +
        "   return length(p)-r;" +
        "}" +
        "void main() {" +
        //"   float x = (gl_FragCoord[0]/250.0)-1.0;"+
        //"   float y = (gl_FragCoord[1]/250.0)-1.0;"+
        "   float x = (zoom * (gl_FragCoord[0]))+xOffset;" +
        "   float y = (zoom * (gl_FragCoord[1]))+yOffset;" +
        ///"   vec2 vTextureCoord = vec2(length(cross(vec3(x,x,x)*t, vec3(y,y,y))),1);" +
        //"   vec2 vTextureCoord = vec2((t * x) / y, .5); " +
        "   vec2 vTextureCoord = vec2(" + showFunc + ", .5); " +
        //"   vec2 vTextureCoord = " + showFunc + ";" +
        "   gl_FragColor = texture2D(uSampler, vTextureCoord);" +
        //"	gl_FragColor = " + showFunc + ";" +
        "}"

    //fragmentShader = "uniform sampler2D uSampler;" +
    //    "void main() {" +
    //    "vec2 vTextureCoord = vec2" +


    var prog = shaderProgram(gl, vertexShader,fragmentShader);
    gl.useProgram(prog);

    xLocc = gl.getUniformLocation(prog, "xOffset");
    yLocc = gl.getUniformLocation(prog, "yOffset");
    tLocc = gl.getUniformLocation(prog, "t");
    zoomLocc = gl.getUniformLocation(prog, "zoom");

    t = 0;
    xOffset = -250;
    yOffset = -250;
    zoom = 1;

    paletteCanvas = document.getElementById("palette");
    texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, paletteCanvas);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    // texture = loadTexture(gl, "texture1d.png");

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);

    return prog;
}

async function draw() {
	gl.clearColor(0.8, 0.8, 0.8, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    var prog = RegenShaders();    

	attributeSetFloats(gl, prog, "pos", 3, [
		-1, 1, 0,
		-1, -1, 0,
		1, -1, 0,
        1, 1, 0,
        -1, 1, 0
    ]);

    //gl.uniform1i(prog.uniformLocations.uSampler, 0);
    locc = gl.getUniformLocation(prog, "uSampler");
    gl.uniform1i(locc, 0);

    direction = 0.01;
    while(true)
    {
        t += direction;
        //t = (new Date).getTime()
        gl.uniform1f(tLocc, t);
        gl.uniform1f(xLocc, xOffset);
        gl.uniform1f(yLocc, yOffset);
        gl.uniform1f(zoomLocc, zoom);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 5);
        await sleep(32);
        // if (t >= 1.0) {
        //     direction = -0.01;
        // }
        // if (t <= -1.0) {
        //     direction = 0.01;
        // }
    }
}

function init() {
	try {
		draw();
	} catch (e) {
		alert("Error: "+e);
	}
}
setTimeout(init, 100);

document.onkeydown = checkKey;

function ZoomIn()
{
    oldZoom = zoom;
    zoom = zoom * 0.9;
    xOffset += (oldZoom * 250) - (zoom * 250);
    yOffset += (oldZoom * 250) - (zoom * 250);
}

function ZoomOut()
{
    oldZoom = zoom;
    zoom = zoom / 0.9;
    xOffset += (oldZoom * 250) - (zoom * 250);
    yOffset += (oldZoom * 250) - (zoom * 250);
}

function checkKey(e) {

    e = e || window.event;

    if (e.keyCode == '38') {
        yOffset += 10 * zoom;
        return false;
    }
    else if (e.keyCode == '40') {
        yOffset -= 10 * zoom;
        return false;
    }
    
    if (e.keyCode == '37') {
       xOffset -= 10 * zoom;
       return false;
    }
    else if (e.keyCode == '39') {
       xOffset += 10 * zoom;
       return false;
    }

    if(e.keyCode == "78")
    {
        ZoomIn();
        return false;
    }
    else if(e.keyCode == "77")
    {
        ZoomOut();
        return false;
    }

    document.getElementById("zoom").textContent = zoom;
    document.getElementById("xOffset").textContent = xOffset;  
    document.getElementById("yOffset").textContent = yOffset;  

    //return false;
}
        
        function CopyLink() {
            var copyText = document.getElementById("showfunc").value;
            var myUrl = location.protocol + '//' + location.host + location.pathname;
            var newUrl = myUrl + "?equation=" + copyText;

            var copyText = document.getElementById("urlText");
            document.getElementById("urlText").value = newUrl;
            copyText.select();
            copyText.setSelectionRange(0, 99999);
            document.execCommand("copy");
        }

function CopyEquation()
{
    var copyText = document.getElementById("showfunc");
    copyText.select();
    copyText.setSelectionRange(0, 99999);
    document.execCommand("copy");
}

function LoadEquation()
{
    var copyText = document.getElementById("showfunc").value;
    RegenShaders(copyText);
}

function LoadPalette()
{
    var equationText = document.getElementById("showfunc").value;
    //var equationHash = equationText.hash;
    Math.seedrandom(equationText);

    var colorArrays = [
  //[0,0,0],
[0,0,188],
[0,0,252],
[0,104,0],
[0,120,0],
[0,120,248],
[0,136,136],
[0,168,0],
[0,168,68],
[0,184,0],
[0,232,216],
[0,252,252],
[0,64,88],
[0,88,0],
[0,88,248],
[104,136,252],
[104,68,252],
[120,120,120],
[124,124,124],
[136,20,0],
[148,0,132],
[152,120,248],
[164,228,252],
[168,0,32],
[168,16,0],
[172,124,0],
[184,184,248],
[184,248,184],
[184,248,216],
[184,248,24],
[188,188,188],
[216,0,204],
[216,184,248],
[216,248,120],
[228,0,88],
[228,92,16],
[240,208,176],
[248,120,248],
[248,120,88],
[248,164,192],
[248,184,0],
[248,184,248],
[248,216,120],
[248,216,248],
[248,248,248],
[248,56,0],
[248,88,152],
[252,160,68],
[252,224,168],
[252,252,252],
[60,188,252],
[68,40,188],
[80,48,0],
[88,216,84],
[88,248,152]  
];

canvas = document.getElementById("palette");
    context = canvas.getContext('2d');
    imageDat = context.getImageData(0,0,canvas.width,canvas.height);
    imageData = imageDat.data;

for(i = 1; i < 16; ++i)
{
    j = Math.floor(Math.random() * colorArrays.length);
    console.log(j);
    col = colorArrays[j];
    colorArrays.splice(j, 1);
    imageData[i*4] = col[0];
    imageData[(i*4)+1] = col[1];
    imageData[(i*4)+2] = col[2];
    imageData[(i*4)+3] = 255;
}

imageData[0] = 0;
imageData[1] = 0;
imageData[2] = 0;
imageData[3] = 255;

context.putImageData(imageDat,0,0);
}
    </script>

<center>
    <table>
        <tr>
            <td colspan="3">
                <center>
                    <canvas id="palette" width="16" height="1" style="width:256px; height:16px;"></canvas>
                </center>
            </td>
        <tr>
            <td>
                <input type="button" onclick="ZoomIn();" value="Zoom In" style="width: 100px; height: 500px"/>
            </td>
            <td>
                <canvas id="webgl" width="500" height="500"></canvas>
            </td>
            <td>
                <input type="button" onclick="ZoomOut();" value="Zoom Out" style="width: 100px; height: 500px"/>
            </td>
        </tr>
    </table>
    <br>
    <input type="button" onclick="requestNew= 1; RegenShaders();" value="New" style="width: 200px; height: 200px;"/>
    <input type="button" onclick="CopyEquation();" value="Copy Equation" style="width: 200px; height: 200px;"/>
    <input type="button" onclick="CopyLink();" value="Copy Link" style="width: 200px; height: 200px;"/>
    <input type="button" onclick="LoadEquation();" value="Load" style="width: 200px; height: 200px;"/>
    <br>
    Complexity: <input type="text" value="140" onchange="complexity=Number(this.value);"/>
    <br>
    <textarea rows="4" cols="50" id="showfunc"/></textarea><br>
    Zoom: <span id="zoom"></span><br>
    Offsets: <span id="xOffset"></span>, <span id="yOffset"></span>
    <input type="text" value="" id="urlText"/>
</center>
</body>
</html>