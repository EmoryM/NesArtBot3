<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Art Bot 3 v0.7</title>
    <style>
            .button {
            background-color: #1c87c9;
            border: none;
            color: white;
            padding: 10px 17px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 20px;
            margin: 4px 2px;
            cursor: pointer;
            }
         </style>
</head>


<body onload="LoadShaderTemplate();">
        <script src="seedrandom.js"></script>
    <script type="text/javascript">

        var shaderTemplate = null;
        var requestNew = 0;
        var showFunc = null;

Array.prototype.random = function() {
    return this[Math.floor(Math.random()*this.length)];
}

String.prototype.hashCode = function() {
  var hash = 0, i, chr;
  if (this.length === 0) return hash;
  for (i = 0; i < this.length; i++) {
    chr   = this.charCodeAt(i);
    hash  = ((hash << 5) - hash) + chr;
    hash |= 0; // Convert to 32bit integer
  }
  return hash;
};

basicFunctions = ["expr+expr", "expr-expr", "expr*expr"];

angleAndTrigFunctions = ["radians(expr)", "degrees(expr)", "sin(expr)", "cos(expr)", "tan(expr)",
    "asin(clamp(expr,-1.0,1.0))", "acos(clamp(expr,-1.0,1.0))", "atan(expr)", "satan(expr,expr)"]; // atan(expr,expr) undefined result if both 0

exponentialFunctions = ["pow(abs(expr), minp(expr))", // argh
    "exp(expr)", "log(minp(expr))", "exp2(expr)", "log2(minp(expr))", "sqrt(abs(expr))",
    "inversesqrt(minp(expr))"];

commonFunctions = ["abs(expr)", "sign(expr)", "floor(expr)", "ceil(expr)", "fract(expr)",
    "mod(expr,expr)", "min(expr,expr)", "max(expr,expr)", "sclamp(expr,expr,expr)", 
    "mix(expr,expr,expr)", "step(expr,expr)", "ssmoothstep(expr,expr,expr)"];

geometricFunctions = ["length(vec2(expr,expr))", "distance(vec2(expr,expr),vec2(expr,expr))",
    "dot(vec2(expr,expr),vec2(expr,expr))"]; // @todo: cross, normalize, faceforward, reflect, refract

// from https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm
// can always add more
signedDistanceFunctions = ["sdSphere(vec3(expr,expr,expr),expr)", "sdBox(vec3(expr,expr,expr),expr)",
    "sdRoundBox(vec3(expr,expr,expr),vec3(expr,expr,expr),expr)", "sdTorus(vec3(expr,expr,expr),vec2(expr,expr))",
    "sdCappedTorus(vec3(expr,expr,expr),vec2(expr,expr),expr,expr)",
    "sdLink(vec3(expr,expr,expr), expr, expr, expr)",
    "sdCylinder(vec3(expr,expr,expr),vec3(expr,expr,expr))",
    "sdCone(vec3(expr,expr,expr),vec2(expr,expr))",
    "sdPlane(vec3(expr,expr,expr),vec4(expr,expr,expr,expr))",
    "sdHexPrism(vec3(expr,expr,expr),vec2(expr,expr))",
    "sdTriPrism(vec3(expr,expr,expr),vec2(expr,expr))",
    "sdCapsule(vec3(expr,expr,expr),vec3(expr,expr,expr),vec3(expr,expr,expr),expr)",
    "sdVerticalCapsule(vec3(expr,expr,expr),expr,expr)",
    "sdCappedCylinder(vec3(expr,expr,expr),expr,expr)",
    "sdRoundedCylinder(vec3(expr,expr,expr),expr,expr,expr)",
    "sdCappedCone(vec3(expr,expr,expr),expr,expr,expr)",
    "sdSolidAngle(vec3(expr,expr,expr), vec2(expr,expr), expr)",
    "sdRoundCone(vec3(expr,expr,expr),expr,expr,expr)",
    "sdEllipsoid(vec3(expr,expr,expr),vec3(expr,expr,expr))",
    "sdOctahedron(vec3(expr,expr,expr),expr)"];

// from https://www.shadertoy.com/view/WdtXWn
stolenFunctionsA = ["hash12(vec2(expr,expr))", "Hash(vec3(expr,expr,expr))", 
    "Noise3d(vec3(expr,expr,expr))", "pModPolar(vec2(expr,expr),expr)", "fOpUnionRound(expr,expr,expr)",
    "smoothAdd(expr,expr,expr)",
    "pyramid(vec3(expr,expr,expr),expr)", "snoise(vec3(expr,expr,expr))"]

// @todo: sample from previous frame for CAs, etc.
// miscFunctions = [ "sR()", "sG()", "sB()",                        // sample previous frame @ this position
//    "sR(expr,expr)", "sG(expr,expr)", "sB(expr,expr)",          // sample previous frame @ x, y position
//    "sRO(expr,expr))", "sGO(expr,expr)", "sBO(expr,expr)"];     // sample previous frame @ this position + offset

allFunctions = basicFunctions.concat(basicFunctions, angleAndTrigFunctions, exponentialFunctions, commonFunctions, geometricFunctions, signedDistanceFunctions, stolenFunctionsA);

allFunctions.push("sR()")

console.log(allFunctions);

var grammar = {
    //'expr': function() { return ['Math.cos(expr)','Math.sin(expr)','expr-expr','expr*expr','expr+expr','expr%expr','Math.abs(expr)','Math.sqrt(expr)','Math.floor(expr)','Math.ceil(expr)','Math.max(expr,expr)','Math.min(expr,expr)','Math.atan2(expr,expr)','sigmoid(expr)','sigmoidd(expr)','Math.pow(expr,expr)','Math.exp(expr)', 'PerlinNoise.noise(expr,expr,expr)', 'Dist(expr,expr,expr,expr)', 'Sign(expr)'].random(); },
    // 'expr': function() { return ['expr+expr', 'expr-expr', 'expr*expr', 
    // 'radians(expr)', 'degrees(expr)', 'sin(expr)', 'cos(expr)', 'tan(expr)', 
    // 'asin(clamp(expr,-1.0,1.0))', 'acos(expr)', 'atan(expr,expr)', 'atan(expr)', 'pow(expr,expr)', 
    // 'exp(expr)', 'log(expr)', 'exp2(expr)', 'log2(expr)', 'sqrt(expr)', 
    // 'inversesqrt(expr)', 'abs(expr)', 'floor(expr)', 'ceil(expr)', 'mod(expr,expr)', 
    // 'min(expr,expr)', 'max(expr,expr)', 'clamp(expr,expr,expr)', 'mix(expr,expr,expr)', 
    // 'step(expr,expr)', 'smoothstep(expr,expr,expr)', 'length(vec2(expr,expr))', 
    // 'distance(vec2(expr,expr),vec2(expr,expr))', 'dot(vec2(expr,expr),vec2(expr,expr))', 
    // 'sdSphere(vec3(expr,expr,expr),expr)', 'sdBox(vec3(expr,expr,expr),expr)', 
    // 'sdTorus(vec3(expr,expr,expr),vec2(expr,expr))', 'sign(expr)'].random(); },
    "expr": function() { return allFunctions.random(); },
    'number': function() { return (10*Math.random()).toFixed(2) },
    'var': function() { 
        var result = ['x','y','t'].random(); 
        if(result == 't')
        {
            usingT = true;
        }
        return result;
    }
};

var complexity = 140;
var randomSeed = (new Date()).getTime();
var seedOffset = 0;
Math.seedrandom(randomSeed+seedOffset);
var glCanvas = null;
var paletteTexture = null;
var canvasTexture = null;
var drawing = true;

function findGetParameter(parameterName) {
    var result = null,
        tmp = [];
    location.search
        .substr(1)
        .split("&")
        .forEach(function (item) {
          tmp = item.split("=");
          if (tmp[0] === parameterName) result = tmp[1];
        });
    return result;
}

var genExpr = function() {
    var str = 'expr';
    var len = complexity;
    var iters = 0;
    while(str.length < len && iters < 50) {
        str = str.replace(/(expr)|(number)|(var)/g, function(repl) {
            return grammar[repl]();
        });
        iters++;
    }
    str = str.replace(/(expr)|(number)|(var)/g, function(repl) {
        if(Math.random() > 0.5) {
            return grammar['var']();
        } else {
            return grammar['number']();
        }
    });
    return str;
}

function shaderProgram(gl, vs, fs) {
	var prog = gl.createProgram();
	var addshader = function(type, source) {
		var s = gl.createShader((type == 'vertex') ?
			gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
		gl.shaderSource(s, source);
		gl.compileShader(s);
		if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
			throw "Could not compile "+type+
				" shader:\n\n"+gl.getShaderInfoLog(s);
		}
		gl.attachShader(prog, s);
	};
	addshader('vertex', vs);
	addshader('fragment', fs);
	gl.linkProgram(prog);
	if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
		throw "Could not link the shader program!";
	}
	return prog;
}

function attributeSetFloats(gl, prog, attr_name, rsize, arr) {
	gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arr),
		gl.STATIC_DRAW);
	var attr = gl.getAttribLocation(prog, attr_name);
	gl.enableVertexAttribArray(attr);
	gl.vertexAttribPointer(attr, rsize, gl.FLOAT, false, 0, 0);
}

function loadTexture(gl, url) {
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);

  // Because images have to be download over the internet
  // they might take a moment until they are ready.
  // Until then put a single pixel in the texture so we can
  // use it immediately. When the image has finished downloading
  // we'll update the texture with the contents of the image.
  const level = 0;
  const internalFormat = gl.RGBA;
  const width = 1;
  const height = 1;
  const border = 0;
  const srcFormat = gl.RGBA;
  const srcType = gl.UNSIGNED_BYTE;
  const pixel = new Uint8Array([0, 0, 255, 255]);  // opaque blue
  gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                width, height, border, srcFormat, srcType,
                pixel);

  const image = new Image();
  image.onload = function() {
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                  srcFormat, srcType, image);

    // WebGL1 has different requirements for power of 2 images
    // vs non power of 2 images so check if the image is a
    // power of 2 in both dimensions.
    //if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
       // Yes, it's a power of 2. Generate mips.
    //   gl.generateMipmap(gl.TEXTURE_2D);
    //} else {
       // No, it's not a power of 2. Turn off mips and set
       // wrapping to clamp to edge
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    //}
  };
  image.src = url;

  return texture;
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

var gl = null;

var xLocc = null;
var yLocc = null;
var tLocc = null;
var zoomLocc = null;

var t = 0;
var xOffset = 0;
var yOffset = 0;
var xDelta = 0;
var yDelta = 0;
var zoom = 1;

var ongoingTouches = [];
var displayFunk = [1,1];

function CalcDisplayFunk()
{
    rect = glCanvas.getBoundingClientRect();
    displayFunk[0] = glCanvas.width / rect.width;
    displayFunk[1] = glCanvas.height / rect.height;
}

function copyTouch(touch) {
  return { identifier: touch.identifier, pageX: touch.pageX, pageY: touch.pageY };
}

function ongoingTouchIndexById(idToFind) {
  for (var i = 0; i < ongoingTouches.length; i++) {
    var id = ongoingTouches[i].identifier;
    
    if (id == idToFind) {
      return i;
    }
  }
  return -1;    // not found
}

function HandleTouchStart(evt)
{
    evt.preventDefault();
    CalcDisplayFunk();   
    var touches = evt.changedTouches;
    for(var i = 0; i < touches.length; ++i)
    {
        ongoingTouches.push(copyTouch(touches[i]));
    }
}

function HandleSingleTouchMove(evt)
{
    evt.preventDefault();
    var touches = evt.changedTouches;
    for(var i = 0; i < touches.length; ++i)
    {
        var idx = ongoingTouchIndexById(touches[i].identifier);
        if(idx >= 0)
        {
            fromX = ongoingTouches[idx].pageX;
            fromY = ongoingTouches[idx].pageY;
            toX = touches[i].pageX;
            toY = touches[i].pageY;
            xOffset += zoom * displayFunk[0] * (fromX - toX);
            yOffset += zoom * displayFunk[1] * (toY - fromY);
            ongoingTouches.splice(idx, 1, copyTouch(touches[i]));
        }
    }
}

function HandleTouchEnd(evt)
{
    evt.preventDefault();
    var touches = evt.changedTouches;
    for(var i = 0; i < touches.length; ++i)
    {
        var idx = ongoingTouchIndexById(touches[i].identifier);
        if(idx >= 0)
        {
            ongoingTouches.splice(idx, 1);
        }
    }
}

function TouchDistanceSq(p1, p2)
{
    return Math.pow(p1.pageX-p2.pageX,2.0) + Math.pow(p1.pageY-p2.pageY,2.0)
}

function HandleTouchMove(evt)
{
    if(evt.touches.length == 1)
    {
        return HandleSingleTouchMove(evt);
    }

    evt.preventDefault();

    d1 = TouchDistanceSq(ongoingTouches[0], ongoingTouches[1]);

    var touches = evt.changedTouches;
    for(var i = 0; i < touches.length; ++i)
    {
        var idx = ongoingTouchIndexById(touches[i].identifier);
        if(idx >= 0)
        {
            ongoingTouches.splice(idx, 1, copyTouch(touches[i]));
        }
    }

    d2 = TouchDistanceSq(ongoingTouches[0], ongoingTouches[1]);

    if(d2 > d1)
    {
        ZoomIn();
        //alert("Zoom in");
    }
    else if(d1 > d2)
    {
        ZoomOut();
        //alert("Zoom out");
    }
    else
    {
        //alert("Same");
    }
}

function GetMousePos(canvasDom, evt)
{
    var rect = canvasDom.getBoundingClientRect();
    return {x: evt.clientX - rect.left, y: evt.clientY - rect.top};
}

var mousePos = {x: 0, y: 0};
var mouseMoving = false;

function HandleMouseStart(evt)
{
    evt.preventDefault();
    CalcDisplayFunk();
    mousePos = GetMousePos(glCanvas, evt);
    mouseMoving = true;
}

function HandleMouseMove(evt)
{
    evt.preventDefault();
    if(mouseMoving)
    {
        newPos = GetMousePos(glCanvas, evt);
        xOffset += zoom * (displayFunk[0] * (mousePos.x - newPos.x));
        yOffset += zoom * (displayFunk[1] * (newPos.y - mousePos.y));
        mousePos = newPos;
    }
}

function HandleMouseEnd(evt)
{
    mouseMoving = false;
}

function HandleMouseZoom(evt)
{
    evt.preventDefault();
    //oldZoom = zoom;
    //console.log(zoom);
    //zoom = zoom - (0.001 * evt.deltaY);
    //console.log(zoom);
    //xOffset += (oldZoom * 250) - (zoom * 250);
    //yOffset += (oldZoom * 250) - (zoom * 250);
    if(evt.deltaY < 0)
    {
        ZoomIn();
    }
    else
    {
        ZoomOut();
    }
}

function LoadShaderTemplate()
{
    var client = new XMLHttpRequest();
    client.open("GET", "shader.txt")
    client.onreadystatechange = function()
    {
        if(client.readyState==4)
        {
            shaderTemplate = client.responseText;
            LoadGL();
        }
    }
    client.send();
}

function LoadGL()
{
    if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) 
    {
        document.getElementById("share_link").style.display = "block";
    }

    document.getElementById("urlText").value = "";
    glCanvas = document.getElementById("webgl");

    // touch movement - finger down, move, finger up
    // based on https://developer.mozilla.org/en-US/docs/Web/API/Touch_events
    glCanvas.addEventListener("touchstart", HandleTouchStart, false);
    glCanvas.addEventListener("touchend", HandleTouchEnd, false);
    glCanvas.addEventListener("touchcancel", HandleTouchEnd, false);
    glCanvas.addEventListener("touchmove", HandleTouchMove, false);

    // mouse movement - left click & drag
    // based on http://bencentra.com/code/2014/12/05/html5-canvas-touch-events.html
    glCanvas.addEventListener("mousedown", HandleMouseStart, false);
    window.addEventListener("mouseup", HandleMouseEnd, false);
    // glCanvas.addEventListener("mouseout", HandleMouseEnd, false);
    glCanvas.addEventListener("mousemove", HandleMouseMove, false);
    glCanvas.addEventListener("wheel", HandleMouseZoom, false);

    try {
		gl = glCanvas.getContext("experimental-webgl");
		if (!gl) { throw "x"; }
	} catch (err) {
		throw "Your web browser does not support WebGL!";
	}

    canvasTexture = InitTexture(gl);

    setTimeout(init, 100);
}

function RegenShaders(shaderText=null)
{
    drawing = false;

    Math.seedrandom(randomSeed+seedOffset+complexity);

    var vertexShader = "attribute vec3 pos;"+
		"void main() {"+
		"	gl_Position = vec4(pos, 1.0);"+
        "}"

    if (shaderText == null) {
        // if we aren't loading with the Load button check the get param
        if (showFunc == null) {
            showFunc = findGetParameter("equation")
            if (showFunc != null) {
                showFunc = atob(showFunc);
            }
        }

        // clicks on New button should always generate a new one
        // else we didn't click Load or have a get param
        if (showFunc == null || requestNew == 1) {
            requestNew = 0;
            showFunc = genExpr();
        }
    }
    else
        showFunc = shaderText
        

    document.getElementById("showfunc").value = showFunc;
    equationText = showFunc;

    CreateLink();
    LoadPalette();

    var fragmentShader = shaderTemplate.replace("<<<showFunc>>>", showFunc);

    var prog = shaderProgram(gl, vertexShader,fragmentShader);
    gl.useProgram(prog);

    xLocc = gl.getUniformLocation(prog, "xOffset");
    yLocc = gl.getUniformLocation(prog, "yOffset");
    tLocc = gl.getUniformLocation(prog, "t");
    zoomLocc = gl.getUniformLocation(prog, "zoom");

    t = 0;
    xOffset = -250;
    yOffset = -250;
    zoom = 1;

    paletteCanvas = document.getElementById("palette");
    paletteTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, paletteTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, paletteCanvas);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    // texture = loadTexture(gl, "texture1d.png");

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, paletteTexture);

    return prog;
}

function InitTexture(gl) {
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);

  // Because video has to be download over the internet
  // they might take a moment until it's ready so
  // put a single pixel in the texture so we can
  // use it immediately.
  const level = 0;
  const internalFormat = gl.RGBA;
  const width = 512;
  const height = 512;
  const border = 0;
  const srcFormat = gl.RGBA;
  const srcType = gl.UNSIGNED_BYTE;
  //const pixel = new Uint8Array([0, 0, 255, 255]);  // opaque blue
  gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                width, height, border, srcFormat, srcType,
                null);

  // Turn off mips and set  wrapping to clamp to edge so it
  // will work regardless of the dimensions of the video.
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  return texture;
}

function UpdateTexture(gl, textur, canvas)
{
    const level = 0;
    const internalFormat = gl.RGBA;
    const srcFormat = gl.RGBA;
    const srcType = gl.UNSIGNED_BYTE;
    
    gl.activeTexture(gl.TEXTURE1);

    //gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, srcFormat, srcType, canvas);

    gl.bindTexture(gl.TEXTURE_2D, textur);

    gl.activeTexture(null);
}

async function draw() {
	gl.clearColor(0.8, 0.8, 0.8, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    var prog = RegenShaders();    

	attributeSetFloats(gl, prog, "pos", 3, [
		-1, 1, 0,
		-1, -1, 0,
		1, -1, 0,
        1, 1, 0,
        -1, 1, 0
    ]);

    //gl.uniform1i(prog.uniformLocations.uSampler, 0);
    locc = gl.getUniformLocation(prog, "uSampler");
    gl.uniform1i(locc, 0);

    loccB = gl.getUniformLocation(prog, "uSamplerB");
    gl.uniform1i(loccB, 1);

    //gl.activeTexture(gl.TEXTURE1);
    
    //gl.bindTexture(gl.TEXTURE_2D, canvasTexture);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, paletteTexture);

    direction = 0.01;
    while(true)
    {
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, paletteTexture);
        
        t += direction;
        //t = (new Date).getTime()
        gl.uniform1f(tLocc, t);
        gl.uniform1f(xLocc, xOffset);
        gl.uniform1f(yLocc, yOffset);
        gl.uniform1f(zoomLocc, zoom);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 5);

        await sleep(32);

        // copy the canvas to a texture
        UpdateTexture(gl, canvasTexture, glCanvas);
        // if (t >= 1.0) {
        //     direction = -0.01;
        // }
        // if (t <= -1.0) {
        //     direction = 0.01;
        // }
    }
}

function init() {
	try {
		draw();
	} catch (e) {
		alert("Error: "+e);
	}
}

//document.onkeydown = checkKey;

function ZoomIn()
{
    oldZoom = zoom;
    //console.log(zoom);
    zoom = zoom * 0.9;
    //console.log(zoom);
    xOffset += (oldZoom * 250) - (zoom * 250);
    yOffset += (oldZoom * 250) - (zoom * 250);
}

function ZoomOut()
{
    oldZoom = zoom;
    //console.log(zoom);
    zoom = zoom / 0.9;
    //console.log(zoom);
    xOffset += (oldZoom * 250) - (zoom * 250);
    yOffset += (oldZoom * 250) - (zoom * 250);
}
        
function CreateLink()
{
    var copyText = document.getElementById("showfunc").value;
    var myUrl = location.protocol + '//' + location.host + location.pathname;
    var lastChar = myUrl[myUrl.length-1]
    if(lastChar=="/")
        myUrl = myUrl.substring(0,myUrl.length-1)
    newUrl = myUrl + "?equation=" + btoa(copyText);
    // document.getElementById("link").value = newUrl;
    document.getElementById("share_link").href = "mailto:artbot@emorym.com?subject=A Cool One!&body=" + newUrl;
    return newUrl;
}

function CopyLink() 
{
    var newUrl = CreateLink();
    var copyText = document.getElementById("urlText");
    document.getElementById("urlText").value = newUrl;
    copyText.select();
    copyText.setSelectionRange(0, 99999);
    document.execCommand("copy");
}

function CopyEquation()
{
    var copyText = document.getElementById("showfunc");
    copyText.select();
    copyText.setSelectionRange(0, 99999);
    document.execCommand("copy");
}

function LoadEquation()
{
    var copyText = document.getElementById("showfunc").value;
    RegenShaders(copyText);
}

function LoadPalette()
{
    var equationText = document.getElementById("showfunc").value;
    //var equationHash = equationText.hash;
    Math.seedrandom(equationText);

    var colorArrays = [
  //[0,0,0],
[0,0,188],
[0,0,252],
[0,104,0],
[0,120,0],
[0,120,248],
[0,136,136],
[0,168,0],
[0,168,68],
[0,184,0],
[0,232,216],
[0,252,252],
[0,64,88],
[0,88,0],
[0,88,248],
[104,136,252],
[104,68,252],
[120,120,120],
[124,124,124],
[136,20,0],
[148,0,132],
[152,120,248],
[164,228,252],
[168,0,32],
[168,16,0],
[172,124,0],
[184,184,248],
[184,248,184],
[184,248,216],
[184,248,24],
[188,188,188],
[216,0,204],
[216,184,248],
[216,248,120],
[228,0,88],
[228,92,16],
[240,208,176],
[248,120,248],
[248,120,88],
[248,164,192],
[248,184,0],
[248,184,248],
[248,216,120],
[248,216,248],
[248,248,248],
[248,56,0],
[248,88,152],
[252,160,68],
[252,224,168],
[252,252,252],
[60,188,252],
[68,40,188],
[80,48,0],
[88,216,84],
[88,248,152]  
];

canvas = document.getElementById("palette");
    context = canvas.getContext('2d');
    context.fillStyle = "black";
    context.fillRect(0, 0, canvas.width, canvas.height);
    imageDat = context.getImageData(0,0,canvas.width,canvas.height);
    imageData = imageDat.data;

for(y = 0; y < 2; ++y)
{
    for(x = 1; x < 16; ++x)
    {
        i = x+(y*16);
        j = Math.floor(Math.random() * colorArrays.length);
        col = colorArrays[j];
        //colorArrays.splice(j, 1);
        imageData[i*4] = col[0];
        imageData[(i*4)+1] = col[1];
        imageData[(i*4)+2] = col[2];
        imageData[(i*4)+3] = 255;
    }
}

context.putImageData(imageDat,0,0);

}
    </script>

<center>
    <canvas id="webgl" width="512" height="512"></canvas><br>

    <center>
        <table>
            <tr>
                <td><a onclick="seedOffset -= 1; requestNew= 1; RegenShaders();" class="button">Prev</a></td>
                <td><a href="mailto:emorym@gmail.com?subject=A Cool One!&body=" id="share_link" class="button" style="display: none;">Share with Emory</a></td>
                <td><a onclick="CopyLink();" class="button">Copy Link</a></td>
                <td><a onclick="LoadEquation();" class="button">Load</a></td>
                <td><a onclick="seedOffset += 1; requestNew= 1; RegenShaders();" class="button">Next</a></td>
            </tr>
        </table>
    </center>
    
    
    <table style="display: none;">
        <tr width="512px">
            <td><input type="button" onclick="seedOffset -= 1; requestNew= 1; RegenShaders();" value="Prev" style="width: 100%;"/></td>
            <td><input type="button" onclick="seedOffset += 1; requestNew= 1; RegenShaders();" value="Next" style="width: 100%;"/></td>
            <!--<td><form action="mailto:artbot@emorym.com"><input type="hidden" name="link" id="link"/><input type="submit" value="Share with Emory" style="width: 100%;"/></form></td>-->
            <td><input type="button" onclick="CopyLink();" value="Copy Link" style="width: 100%;"/></td>
        </tr>
    </table>
    <br>
    Complexity: <input type="text" value="140" onchange="complexity=Number(this.value);"/>
    <br>
    <textarea rows="4" cols="50" id="showfunc"/></textarea><br>
    <!-- Zoom: <span id="zoom"></span><br>
    Offsets: <span id="xOffset"></span>, <span id="yOffset"></span> -->
    <input type="text" value="" id="urlText"/>
    <center><canvas id="palette" width="16" height="2" style="width:16px; height:2px;"></canvas></center><br>
</center>
</body>
</html>