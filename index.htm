<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Art Bot 3 v0.8</title>
    <link href="https://fonts.googleapis.com/css?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
            .button {
            font-family: 'Press Start 2P', cursive;
            background-color: #1c87c9;
            border: none;
            color: white;
            padding: 10px 17px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            /* font-size: 20px; */
            margin: 4px 2px;
            cursor: pointer;
            }

            .secret {
                display: none;
            }

            .activebutt {
              /* Start the shake animation and make the animation last for 0.5 seconds */
              /* animation: shake 5.0s; */
              /* animation: shadow-pulse 1s infinite; */
              /* animation: pulse 5s infinite; */

              /* When the animation is finished, start again */
              /* animation-iteration-count: infinite; */
              transform: rotate(15deg);
            }

            @keyframes pulse {
            0% {
                transform: scale(0.9);
            }

            70% {
                transform: scale(1);
            }

            100% {
                transform: scale(0.9);
            }
        }

            @keyframes shadow-pulse
            {
                 0% {
                      box-shadow: 0 0 0 0px rgba(0, 0, 0, 0.2);
                 }
                 100% {
                      box-shadow: 0 0 0 35px rgba(0, 0, 0, 0);
                 }
            }

            @keyframes shake {
              0% { transform: translate(1px, 1px) rotate(0deg); }
              10% { transform: translate(-1px, -2px) rotate(-1deg); }
              20% { transform: translate(-3px, 0px) rotate(1deg); }
              30% { transform: translate(3px, 2px) rotate(0deg); }
              40% { transform: translate(1px, -1px) rotate(1deg); }
              50% { transform: translate(-1px, 2px) rotate(-1deg); }
              60% { transform: translate(-3px, 1px) rotate(0deg); }
              70% { transform: translate(3px, 1px) rotate(-1deg); }
              80% { transform: translate(-1px, -1px) rotate(1deg); }
              90% { transform: translate(1px, 2px) rotate(0deg); }
              100% { transform: translate(1px, -2px) rotate(-1deg); }
            }

            .noselect {
              -webkit-touch-callout: none; /* iOS Safari */
                -webkit-user-select: none; /* Safari */
                 -khtml-user-select: none; /* Konqueror HTML */
                   -moz-user-select: none; /* Old versions of Firefox */
                    -ms-user-select: none; /* Internet Explorer/Edge */
                        user-select: none; /* Non-prefixed version, currently
                                              supported by Chrome, Opera and Firefox */
            }
         </style>
</head>

<body onload="LoadShaderTemplate();" style="background-color: black;">
<script src="seedrandom.js"></script>
<script type="text/javascript">
    var shaderTemplate = null;
    var requestNew = 0;
    var showFunc = null;
    var complexity = 140;
    var randomSeed = (new Date()).getTime();
    var seedOffset = 0; // for previous and next buttons
    var glCanvas = null;
    var bufferCanvas = null;
    var bufferContext = null;
    var bufferTexture = null;
    var gl = null;
    var xLocc = null;
    var yLocc = null;
    var tLocc = null;
    var zoomLocc = null;
    var t = 0;
    var xOffset = 0;
    var yOffset = 0;
    var xDelta = 0;
    var yDelta = 0;
    var zoom = 1.001;
    var speed = 0.01;
    var oldSpeed = 0.01;

    var backbufferFunctions = ["sR", "sG", "sB"]
    var backbuffer = true;
    var bbStep = false;

    var ongoingTouches = [];
    var displayFunk = [1,1];

    Array.prototype.random = function()
    {
        return this[Math.floor(Math.random()*this.length)];
    }

    String.prototype.hashCode = function()
    {
      var hash = 0, i, chr;
      if (this.length === 0) return hash;
      for (i = 0; i < this.length; i++) {
        chr   = this.charCodeAt(i);
        hash  = ((hash << 5) - hash) + chr;
        hash |= 0; // Convert to 32bit integer
      }
      return hash;
    };

    function findGetParameter(parameterName)
    {
        var result = null,
            tmp = [];
        location.search
            .substr(1)
            .split("&")
            .forEach(function (item) {
              tmp = item.split("=");
              if (tmp[0] === parameterName) result = tmp[1];
            });
        return result;
    }

    function loadGetParameters()
    {
        link_x = findGetParameter("x")
        link_y = parseFloat(findGetParameter("y"))
        link_z = parseFloat(findGetParameter("z"))
        link_t = parseFloat(findGetParameter("t"))
        link_s = parseFloat(findGetParameter("s")) / 10000.0

        if(link_x != null)
        {
            xOffset = parseFloat(link_x)
            yOffset = link_y
            zoom = link_z
            t = link_t
            speed = link_s

            console.log(xOffset, yOffset, zoom, t, speed)

            document.getElementById("speedSlider").value = speed * 10000;
        }
    }

    function shaderProgram(gl, vs, fs)
    {
        var prog = gl.createProgram();
        var addshader = function(type, source) {
            var s = gl.createShader((type == 'vertex') ?
                gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
            gl.shaderSource(s, source);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                throw "Could not compile "+type+
                    " shader:\n\n"+gl.getShaderInfoLog(s);
            }
            gl.attachShader(prog, s);
        };
        addshader('vertex', vs);
        addshader('fragment', fs);
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
            console.log("Could not link the shader program!");
            throw "Could not link the shader program!";

        }

        console.log("Returning shader program");
        return prog;
    }

    function attributeSetFloats(gl, prog, attr_name, rsize, arr) {
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arr),
            gl.STATIC_DRAW);
        var attr = gl.getAttribLocation(prog, attr_name);
        gl.enableVertexAttribArray(attr);
        gl.vertexAttribPointer(attr, rsize, gl.FLOAT, false, 0, 0);
    }

    function CalcDisplayFunk()
    {
        rect = glCanvas.getBoundingClientRect();
        displayFunk[0] = glCanvas.width / rect.width;
        displayFunk[1] = glCanvas.height / rect.height;
    }

    function copyTouch(touch) {
      return { identifier: touch.identifier, pageX: touch.pageX, pageY: touch.pageY };
    }

    function ongoingTouchIndexById(idToFind) {
      for (var i = 0; i < ongoingTouches.length; i++) {
        var id = ongoingTouches[i].identifier;

        if (id == idToFind) {
          return i;
        }
      }
      return -1;    // not found
    }

    function HandleTouchStart(evt)
    {
        evt.preventDefault();
        CalcDisplayFunk();
        var touches = evt.changedTouches;
        for(var i = 0; i < touches.length; ++i)
        {
            ongoingTouches.push(copyTouch(touches[i]));
        }
    }

    function HandleSingleTouchMove(evt)
    {
        evt.preventDefault();
        var touches = evt.changedTouches;
        for(var i = 0; i < touches.length; ++i)
        {
            var idx = ongoingTouchIndexById(touches[i].identifier);
            if(idx >= 0)
            {
                fromX = ongoingTouches[idx].pageX;
                fromY = ongoingTouches[idx].pageY;
                toX = touches[i].pageX;
                toY = touches[i].pageY;
                xOffset += zoom * displayFunk[0] * (fromX - toX);
                yOffset += zoom * displayFunk[1] * (toY - fromY);
                ongoingTouches.splice(idx, 1, copyTouch(touches[i]));
            }
        }
    }

    function HandleTouchEnd(evt)
    {
        evt.preventDefault();
        var touches = evt.changedTouches;
        for(var i = 0; i < touches.length; ++i)
        {
            var idx = ongoingTouchIndexById(touches[i].identifier);
            if(idx >= 0)
            {
                ongoingTouches.splice(idx, 1);
            }
        }
    }

    function TouchDistanceSq(p1, p2)
    {
        return Math.pow(p1.pageX-p2.pageX,2.0) + Math.pow(p1.pageY-p2.pageY,2.0)
    }

    function HandleTouchMove(evt)
    {
        if(evt.touches.length == 1)
        {
            return HandleSingleTouchMove(evt);
        }

        evt.preventDefault();

        d1 = TouchDistanceSq(ongoingTouches[0], ongoingTouches[1]);

        var touches = evt.changedTouches;
        for(var i = 0; i < touches.length; ++i)
        {
            var idx = ongoingTouchIndexById(touches[i].identifier);
            if(idx >= 0)
            {
                ongoingTouches.splice(idx, 1, copyTouch(touches[i]));
            }
        }

        d2 = TouchDistanceSq(ongoingTouches[0], ongoingTouches[1]);

        if(d2 > d1)
        {
            ZoomIn();
            //alert("Zoom in");
        }
        else if(d1 > d2)
        {
            ZoomOut();
            //alert("Zoom out");
        }
        else
        {
            //alert("Same");
        }
    }

    function GetMousePos(canvasDom, evt)
    {
        var rect = canvasDom.getBoundingClientRect();
        return {x: evt.clientX - rect.left, y: evt.clientY - rect.top};
    }

    var mousePos = {x: 0, y: 0};
    var mouseMoving = false;

    function HandleMouseStart(evt)
    {
        evt.preventDefault();
        CalcDisplayFunk();
        mousePos = GetMousePos(glCanvas, evt);
        mouseMoving = true;
    }

    function HandleMouseMove(evt)
    {
        evt.preventDefault();
        if(mouseMoving)
        {
            newPos = GetMousePos(glCanvas, evt);
            xOffset += zoom * (displayFunk[0] * (mousePos.x - newPos.x));
            yOffset += zoom * (displayFunk[1] * (newPos.y - mousePos.y));
            mousePos = newPos;
        }
    }

    function HandleMouseEnd(evt)
    {
        mouseMoving = false;
    }

    function HandleMouseZoom(evt)
    {
        evt.preventDefault();
        //oldZoom = zoom;
        //console.log(zoom);
        //zoom = zoom - (0.001 * evt.deltaY);
        //console.log(zoom);
        //xOffset += (oldZoom * 250) - (zoom * 250);
        //yOffset += (oldZoom * 250) - (zoom * 250);
        if(evt.deltaY < 0)
        {
            ZoomIn();
        }
        else
        {
            ZoomOut();
        }
    }

    function LoadShaderTemplate()
    {
        var client = new XMLHttpRequest();
        client.open("GET", "shader.glsl")
        client.onreadystatechange = function()
        {
            if(client.readyState==4)
            {
                shaderTemplate = client.responseText;
                Init();
            }
        }
        client.send();
    }

    function ZoomIn()
    {
        oldZoom = zoom;
        //console.log(zoom);
        zoom = zoom * 0.9;
        //console.log(zoom);
        console.log(xOffset)
        xOffset += (oldZoom * 250) - (zoom * 250);
        yOffset += (oldZoom * 250) - (zoom * 250);
    }

    function ZoomOut()
    {
        oldZoom = zoom;
        //console.log(zoom);
        zoom = zoom / 0.9;
        //console.log(zoom);
        xOffset += (oldZoom * 250) - (zoom * 250);
        yOffset += (oldZoom * 250) - (zoom * 250);
    }

    function Encode(textData)
    {
        transformed = btoa(transformed)
        return transformed
    }

    function Decode(textData)
    {
        transformed = atob(textData)
        return transformed
    }

    function CreateLink()
    {
        //CopyEquation();
        var copyText = document.getElementById("showfunc").value;
        var myUrl = location.protocol + '//' + location.host;
        console.log(myUrl)
        myUrl += location.pathname;
        var lastChar = myUrl[myUrl.length-1]
        if(lastChar=="/")
            myUrl = myUrl.substring(0,myUrl.length-1)
        myUrl = myUrl + "?x=" + xOffset.toFixed(2) + "&y=" + yOffset.toFixed(2) + "&z=" + zoom.toFixed(2) + "&t=" + t.toFixed(2) + "&s=" + Math.floor(speed*10000);
        newUrl = myUrl + "&equation=" + Encode(copyText);
        // document.getElementById("link").value = newUrl;
        document.getElementById("share_link").href = "mailto:artbot@emorym.com?subject=A Cool One!&body=" + newUrl;
        return newUrl;
    }

    function CopyLink()
    {
        secrets = document.getElementById("secrets");
        secrets.classList.remove("secret");

        var newUrl = CreateLink();
        var copyText = document.getElementById("urlText");
        document.getElementById("urlText").value = newUrl;
        copyText.select();
        copyText.setSelectionRange(0, 99999);
        document.execCommand("copy");

        secrets.classList.add("secret");
    }

    function CopyEquation()
    {
        var copyText = document.getElementById("showfunc");
        copyText.select();
        copyText.setSelectionRange(0, 99999);
        document.execCommand("copy");
    }

    function LoadEquation()
    {
        var copyText = document.getElementById("showfunc").value;
        RegenShaders(copyText);
    }

    function LoadPalette()
    {
        var equationText = document.getElementById("showfunc").value;
        //var equationHash = equationText.hash;
        Math.seedrandom(equationText);

        var colorArrays = [
      //[0,0,0],
        [0,0,188],
        [0,0,252],
        [0,104,0],
        [0,120,0],
        [0,120,248],
        [0,136,136],
        [0,168,0],
        [0,168,68],
        [0,184,0],
        [0,232,216],
        [0,252,252],
        [0,64,88],
        [0,88,0],
        [0,88,248],
        [104,136,252],
        [104,68,252],
        [120,120,120],
        [124,124,124],
        [136,20,0],
        [148,0,132],
        [152,120,248],
        [164,228,252],
        [168,0,32],
        [168,16,0],
        [172,124,0],
        [184,184,248],
        [184,248,184],
        [184,248,216],
        [184,248,24],
        [188,188,188],
        [216,0,204],
        [216,184,248],
        [216,248,120],
        [228,0,88],
        [228,92,16],
        [240,208,176],
        [248,120,248],
        [248,120,88],
        [248,164,192],
        [248,184,0],
        [248,184,248],
        [248,216,120],
        [248,216,248],
        [248,248,248],
        [248,56,0],
        [248,88,152],
        [252,160,68],
        [252,224,168],
        [252,252,252],
        [60,188,252],
        [68,40,188],
        [80,48,0],
        [88,216,84],
        [88,248,152]
        ];

        canvas = document.getElementById("palette");
        context = canvas.getContext('2d');
        context.fillStyle = "black";
        context.fillRect(0, 0, canvas.width, canvas.height);
        imageDat = context.getImageData(0,0,canvas.width,canvas.height);
        imageData = imageDat.data;

        for(y = 0; y < 2; ++y)
        {
            for(x = 1; x < 16; ++x)
            {
                i = x+(y*16);
                j = Math.floor(Math.random() * colorArrays.length);
                col = colorArrays[j];
                //colorArrays.splice(j, 1);
                imageData[i*4] = col[0];
                imageData[(i*4)+1] = col[1];
                imageData[(i*4)+2] = col[2];
                imageData[(i*4)+3] = 255;
            }
        }

        context.putImageData(imageDat,0,0);
    }

    function LoadGL()
    {
        if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) )
        {
            document.getElementById("share_link").style.display = "block";
        }
        document.getElementById("share_link").style.display = "block";

        document.getElementById("urlText").value = "";
        glCanvas = document.getElementById("webgl");
        bufferCanvas = document.getElementById("buffer");
        bufferContext = bufferCanvas.getContext("2d");

        // touch movement - finger down, move, finger up
        // based on https://developer.mozilla.org/en-US/docs/Web/API/Touch_events
        glCanvas.addEventListener("touchstart", HandleTouchStart, false);
        glCanvas.addEventListener("touchend", HandleTouchEnd, false);
        glCanvas.addEventListener("touchcancel", HandleTouchEnd, false);
        glCanvas.addEventListener("touchmove", HandleTouchMove, false);

        // mouse movement - left click & drag
        // based on http://bencentra.com/code/2014/12/05/html5-canvas-touch-events.html
        glCanvas.addEventListener("mousedown", HandleMouseStart, false);
        window.addEventListener("mouseup", HandleMouseEnd, false);
        // glCanvas.addEventListener("mouseout", HandleMouseEnd, false);
        glCanvas.addEventListener("mousemove", HandleMouseMove, false);
        glCanvas.addEventListener("wheel", HandleMouseZoom, false);

        try {
            gl = glCanvas.getContext("experimental-webgl");
            if (!gl) { throw "x"; }
        } catch (err) {
            console.log("No WebGL!");
            throw "Your web browser does not support WebGL!";
        }
    }

    function CreatePaletteTexture0()
    {
        gl.activeTexture(gl.TEXTURE0);

        paletteCanvas = document.getElementById("palette");
        paletteTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, paletteTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, paletteCanvas);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, paletteTexture);
        gl.activeTexture(gl.TEXTURE2);
    }

    function CreateBufferTexture1()
    {
        gl.activeTexture(gl.TEXTURE1);

        // should have this in LoadGL()
        bufferCanvas = document.getElementById("buffer");
        bufferTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, bufferTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bufferCanvas);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, bufferTexture);
        gl.activeTexture(gl.TEXTURE2);
    }

    function RegenShaders(shaderText=null)
    {
        // clear the backbuffer
        backbuffer = false
        bufferContext.fillStyle = "black";
        bufferContext.fillRect(0, 0, bufferCanvas.width, bufferCanvas.height);

        //speed = 0.01;

        Math.seedrandom(randomSeed+seedOffset+complexity);

        var vertexShader = "attribute vec3 pos;"+
            "void main() {"+
            "	gl_Position = vec4(pos, 1.0);"+
            "}"

        offsetsInUrl = false

        if (shaderText == null)
        {
            // if we aren't loading with the Load button check the get param
            if (showFunc == null)
            {
                showFunc = findGetParameter("equation")
                if (showFunc != null)
                {
                    offsetsInUrl = true
                    showFunc = Decode(showFunc);
                }
            }

            // clicks on New button should always generate a new one
            // else we didn't click Load or have a get param
            if (showFunc == null || requestNew == 1)
            {
                requestNew = 0;
                showFunc = genExpr();
            }
        }
        else
            showFunc = shaderText

        document.getElementById("showfunc").value = showFunc;
        equationText = showFunc;

        CreateLink();
        LoadPalette();

        // don't want to waste time if we don't need to
        backbuffer = false;
        for(i = 0; i < backbufferFunctions.length; ++i)
        {
            if(showFunc.includes(backbufferFunctions[i]))
                backbuffer = true;
        }

        if(backbuffer)
            console.log("backbuffered")
        else
            console.log("no backbuffer")

        var fragmentShader = shaderTemplate.replace("<<<showFunc>>>", showFunc);
        //console.log(fragmentShader);

        var prog = shaderProgram(gl, vertexShader,fragmentShader);
        gl.useProgram(prog);

        xLocc = gl.getUniformLocation(prog, "xOffset");
        yLocc = gl.getUniformLocation(prog, "yOffset");
        tLocc = gl.getUniformLocation(prog, "t");
        zoomLocc = gl.getUniformLocation(prog, "zoom");

        t = 0;
        xOffset = -250.1;
        yOffset = -250.1;
        zoom = 1.001;

        if(offsetsInUrl)
            loadGetParameters();

        CreatePaletteTexture0();
        CreateBufferTexture1();

        return prog;
    }

    function RenderingSetup()
    {
        // ah yes, ERROR GREY
        gl.clearColor(0.8, 0.8, 0.8, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        prog = RegenShaders();

        attributeSetFloats(gl, prog, "pos", 3, [
            -1, 1, 0,
            -1, -1, 0,
            1, -1, 0,
            1, 1, 0,
            -1, 1, 0
        ]);

        paletteSamplerLocation = gl.getUniformLocation(prog, "palette");
        gl.uniform1i(paletteSamplerLocation, 0);

        bufferSamplerLocation = gl.getUniformLocation(prog, "lastFrame");
        gl.uniform1i(bufferSamplerLocation, 1);

        draw();
    }

    function draw()
    {
        gl.clearColor(0.8, 0.8, 0.8, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // set shader values
        t += speed;
        gl.uniform1f(tLocc, t);
        gl.uniform1f(xLocc, xOffset);
        gl.uniform1f(yLocc, yOffset);
        gl.uniform1f(zoomLocc, zoom);

        // perform the drawing
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 5);

        if((speed != 0 || bbStep) && backbuffer)
        {
            bbStep = false;

            // copy the GL canvas to the buffer canvas
            bufferContext.drawImage(glCanvas, 0, 0);


            // set the buffer texture to the contents of the buffer canvas
            gl.activeTexture(gl.TEXTURE1);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bufferCanvas);
            gl.activeTexture(gl.TEXTURE0);
        }

        window.requestAnimationFrame(draw);
    }

    function PlayPause()
    {
        if(speed == 0)
        {
            speed = oldSpeed;
        }
        else
        {
            oldSpeed = speed;
            speed = 0;
        }
    }

    function Rewind()
    {
        if(speed == 0)
        {
            t -= Math.abs(oldSpeed);
            bbStep = true;
        }
        else
        {
            //speed = Math.min(-0.01, speed - 0.01);
            speed = -1.0 * Math.abs(speed);
        }
    }

    function FastForward()
    {
        if(speed == 0)
        {
            t += Math.abs(oldSpeed);
            bbStep = true;
        }
        else
        {
            //speed = Math.max(0.02, speed + 0.01);
            speed = Math.abs(speed);
        }
    }

    function SlowDown()
    {
        if(speed == 0)
        {
            if(Math.abs(oldSpeed * 0.5)>0.00000001)
                oldSpeed *= 0.5;
        }
        else
        {
            if(Math.abs(speed * 0.5)>0.00000001)
                speed *= 0.5;
        }
    }

    function SpeedUp()
    {
        if(speed == 0)
            oldSpeed *= 2.0;
        else
            speed = speed * 2.0;
    }

    function AssignStyles()
    {
        slowdown = document.getElementById("slowdown");
        rewind = document.getElementById("rewind");
        playpause = document.getElementById("playpause");
        fastforward = document.getElementById("fastforward");
        speedup = document.getElementById("speedup");

        eS = speed == 0 ? oldSpeed : speed;

        if(speed==0)
            playpause.classList.remove("activebutt");
        else
            playpause.classList.add("activebutt");

        if(Math.abs(eS)<0.0075)
        {
            slowdown.classList.add("activebutt");
            speedup.classList.remove("activebutt");
        }
        else if(Math.abs(eS)>0.015)
        {
            slowdown.classList.remove("activebutt");
            speedup.classList.add("activebutt");
        }
        else
        {
            slowdown.classList.remove("activebutt");
            speedup.classList.remove("activebutt");
        }

        if(eS>0)
        {
            fastforward.classList.add("activebutt");
            rewind.classList.remove("activebutt");
        }
        else
        {
            fastforward.classList.remove("activebutt");
            rewind.classList.add("activebutt");
        }
    }

    function Init()
    {
        Math.seedrandom(randomSeed+seedOffset);
        LoadGL();
        RenderingSetup();
        //RegenShaders();
        draw();
    }

    buttons = null;

    function ResizeCanvas(multiplier)
    {
        s = Math.floor(512.0*multiplier);
        glCanvas.style.width = s + "px";
        glCanvas.style.height = s + "px";

        if(buttons==null)
        {
            buttons = document.getElementsByClassName("button")
            console.log(buttons);
            console.log(buttons.length);
        }

        fs = Math.floor(20.0*multiplier);

        for(i=0; i<buttons.length; ++i)
        {
            buttons[i].style.fontSize = fs + "px";
        }
    }
</script>
<script src="generator.js"></script>

<center>
    <div class="slidecontainer" style="width: 512px;">
      <input type="range" min="100.0" max="200.0" value="100.0" class="slider" id="sizeSlider" style="width: 512px;" onpointermove="ResizeCanvas(this.value/100.0);" onchange="ResizeCanvas(this.value/100.0);">
    </div>
    <canvas id="webgl" width="512" height="512" style="height: 512px; width: 512px; image-rendering: pixelated;"></canvas>
    <center>
        <table style="display: none;">
            <tr width="512px">
                <td><div style="font-size: 40px; cursor: pointer;" onclick="SlowDown(); AssignStyles();" class="noselect" id="slowdown">üê¢</div></td>
                <td><div style="font-size: 40px; cursor: pointer;" onclick="Rewind(); AssignStyles();" class="noselect" id="rewind">‚è™</div></td>
                <td><div style="font-size: 40px; cursor: pointer;" onclick="PlayPause(); AssignStyles();" class="noselect activebutt" id="playpause">‚èØ</div></td>
                <td><div style="font-size: 40px; cursor: pointer;" onclick="FastForward(); AssignStyles();" class="noselect activebutt" id="fastforward">‚è©</div></td>
                <td><div style="font-size: 40px; cursor: pointer;" onclick="SpeedUp(); AssignStyles();" class="noselect" id="speedup">üêá</div></td>
            </tr>
        </table>
        <div class="slidecontainer" style="width: 512px;">
          <input type="range" min="-100.0" max="100.0" value="100.0" class="slider" id="speedSlider" style="width: 512px;" onpointermove="speed=this.value/10000.0; return false;" onchange="speed=this.value/10000.0; return false;">
        </div>
        <table>
            <tr>
                <td><a onclick="seedOffset -= 1; requestNew= 1; RegenShaders();" class="button">Prev</a></td>
                <td><a href="mailto:emorym@gmail.com?subject=A Cool One!&body=" id="share_link" class="button" style="display: none;">Share with Emory</a></td>
                <td><a onclick="CopyLink();" class="button">Copy Link</a></td>
                <td><a onclick="seedOffset += 1; requestNew= 1; RegenShaders();" class="button">Next</a></td>
            </tr>
        </table>
    </center>
    <div id="secrets" class="secret">
        <canvas id="buffer" width="512" height="512"></canvas><br>
        <br>
        Complexity: <input type="text" value="140" onchange="complexity=Number(this.value);"/>
        <br>
        <textarea rows="10" cols="100" id="showfunc"/></textarea><br>
        <a onclick="LoadEquation();" class="button">Load</a><br>
        Zoom: <span id="zoom"></span><br>
        Offsets: <span id="xOffset"></span>, <span id="yOffset"></span><br>
        Speed: <span id="speed"></span><br>
        <input type="text" value="" id="urlText"/>
        <center><canvas id="palette" width="16" height="2" style="width:16px; height:2px;"></canvas></center><br>
    </div>
</center>
</body>
</html>