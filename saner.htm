<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Art Bot 3 v0.7</title>
    <style>
            .button {
            background-color: #1c87c9;
            border: none;
            color: white;
            padding: 10px 17px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 20px;
            margin: 4px 2px;
            cursor: pointer;
            }
         </style>
</head>

<body onload="LoadShaderTemplate();">
<script src="seedrandom.js"></script>

<script type="text/javascript">
    var shaderTemplate = null;
    var requestNew = 0;
    var showFunc = null;
    var complexity = 140;
    var randomSeed = (new Date()).getTime();
    var seedOffset = 0; // for previous and next buttons
    var glCanvas = null;
    var bufferCanvas = null;
    var bufferContext = null;
    var bufferTexture = null;
    var gl = null;
    var xLocc = null;
    var yLocc = null;
    var tLocc = null;
    var zoomLocc = null;
    var t = 0;
    var xOffset = 0;
    var yOffset = 0;
    var xDelta = 0;
    var yDelta = 0;
    var zoom = 1;

    var ongoingTouches = [];
    var displayFunk = [1,1];

    Array.prototype.random = function()
    {
        return this[Math.floor(Math.random()*this.length)];
    }

    String.prototype.hashCode = function()
    {
      var hash = 0, i, chr;
      if (this.length === 0) return hash;
      for (i = 0; i < this.length; i++) {
        chr   = this.charCodeAt(i);
        hash  = ((hash << 5) - hash) + chr;
        hash |= 0; // Convert to 32bit integer
      }
      return hash;
    };

    function findGetParameter(parameterName)
    {
        var result = null,
            tmp = [];
        location.search
            .substr(1)
            .split("&")
            .forEach(function (item) {
              tmp = item.split("=");
              if (tmp[0] === parameterName) result = tmp[1];
            });
        return result;
    }

    function shaderProgram(gl, vs, fs)
    {
        var prog = gl.createProgram();
        var addshader = function(type, source) {
            var s = gl.createShader((type == 'vertex') ?
                gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
            gl.shaderSource(s, source);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                throw "Could not compile "+type+
                    " shader:\n\n"+gl.getShaderInfoLog(s);
            }
            gl.attachShader(prog, s);
        };
        addshader('vertex', vs);
        addshader('fragment', fs);
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
            console.log("Could not link the shader program!");
            throw "Could not link the shader program!";

        }

        console.log("Returning shader program");
        return prog;
    }

    function attributeSetFloats(gl, prog, attr_name, rsize, arr) {
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arr),
            gl.STATIC_DRAW);
        var attr = gl.getAttribLocation(prog, attr_name);
        gl.enableVertexAttribArray(attr);
        gl.vertexAttribPointer(attr, rsize, gl.FLOAT, false, 0, 0);
    }

    function CalcDisplayFunk()
    {
        rect = glCanvas.getBoundingClientRect();
        displayFunk[0] = glCanvas.width / rect.width;
        displayFunk[1] = glCanvas.height / rect.height;
    }

    function copyTouch(touch) {
      return { identifier: touch.identifier, pageX: touch.pageX, pageY: touch.pageY };
    }

    function ongoingTouchIndexById(idToFind) {
      for (var i = 0; i < ongoingTouches.length; i++) {
        var id = ongoingTouches[i].identifier;

        if (id == idToFind) {
          return i;
        }
      }
      return -1;    // not found
    }

    function HandleTouchStart(evt)
    {
        evt.preventDefault();
        CalcDisplayFunk();
        var touches = evt.changedTouches;
        for(var i = 0; i < touches.length; ++i)
        {
            ongoingTouches.push(copyTouch(touches[i]));
        }
    }

    function HandleSingleTouchMove(evt)
    {
        evt.preventDefault();
        var touches = evt.changedTouches;
        for(var i = 0; i < touches.length; ++i)
        {
            var idx = ongoingTouchIndexById(touches[i].identifier);
            if(idx >= 0)
            {
                fromX = ongoingTouches[idx].pageX;
                fromY = ongoingTouches[idx].pageY;
                toX = touches[i].pageX;
                toY = touches[i].pageY;
                xOffset += zoom * displayFunk[0] * (fromX - toX);
                yOffset += zoom * displayFunk[1] * (toY - fromY);
                ongoingTouches.splice(idx, 1, copyTouch(touches[i]));
            }
        }
    }

    function HandleTouchEnd(evt)
    {
        evt.preventDefault();
        var touches = evt.changedTouches;
        for(var i = 0; i < touches.length; ++i)
        {
            var idx = ongoingTouchIndexById(touches[i].identifier);
            if(idx >= 0)
            {
                ongoingTouches.splice(idx, 1);
            }
        }
    }

    function TouchDistanceSq(p1, p2)
    {
        return Math.pow(p1.pageX-p2.pageX,2.0) + Math.pow(p1.pageY-p2.pageY,2.0)
    }

    function HandleTouchMove(evt)
    {
        if(evt.touches.length == 1)
        {
            return HandleSingleTouchMove(evt);
        }

        evt.preventDefault();

        d1 = TouchDistanceSq(ongoingTouches[0], ongoingTouches[1]);

        var touches = evt.changedTouches;
        for(var i = 0; i < touches.length; ++i)
        {
            var idx = ongoingTouchIndexById(touches[i].identifier);
            if(idx >= 0)
            {
                ongoingTouches.splice(idx, 1, copyTouch(touches[i]));
            }
        }

        d2 = TouchDistanceSq(ongoingTouches[0], ongoingTouches[1]);

        if(d2 > d1)
        {
            ZoomIn();
            //alert("Zoom in");
        }
        else if(d1 > d2)
        {
            ZoomOut();
            //alert("Zoom out");
        }
        else
        {
            //alert("Same");
        }
    }

    function GetMousePos(canvasDom, evt)
    {
        var rect = canvasDom.getBoundingClientRect();
        return {x: evt.clientX - rect.left, y: evt.clientY - rect.top};
    }

    var mousePos = {x: 0, y: 0};
    var mouseMoving = false;

    function HandleMouseStart(evt)
    {
        evt.preventDefault();
        CalcDisplayFunk();
        mousePos = GetMousePos(glCanvas, evt);
        mouseMoving = true;
    }

    function HandleMouseMove(evt)
    {
        evt.preventDefault();
        if(mouseMoving)
        {
            newPos = GetMousePos(glCanvas, evt);
            xOffset += zoom * (displayFunk[0] * (mousePos.x - newPos.x));
            yOffset += zoom * (displayFunk[1] * (newPos.y - mousePos.y));
            mousePos = newPos;
        }
    }

    function HandleMouseEnd(evt)
    {
        mouseMoving = false;
    }

    function HandleMouseZoom(evt)
    {
        evt.preventDefault();
        //oldZoom = zoom;
        //console.log(zoom);
        //zoom = zoom - (0.001 * evt.deltaY);
        //console.log(zoom);
        //xOffset += (oldZoom * 250) - (zoom * 250);
        //yOffset += (oldZoom * 250) - (zoom * 250);
        if(evt.deltaY < 0)
        {
            ZoomIn();
        }
        else
        {
            ZoomOut();
        }
    }

    function LoadShaderTemplate()
    {
        var client = new XMLHttpRequest();
        client.open("GET", "shader.glsl")
        client.onreadystatechange = function()
        {
            if(client.readyState==4)
            {
                shaderTemplate = client.responseText;
                Init();
            }
        }
        client.send();
    }

    function ZoomIn()
    {
        oldZoom = zoom;
        //console.log(zoom);
        zoom = zoom * 0.9;
        //console.log(zoom);
        xOffset += (oldZoom * 250) - (zoom * 250);
        yOffset += (oldZoom * 250) - (zoom * 250);
    }

    function ZoomOut()
    {
        oldZoom = zoom;
        //console.log(zoom);
        zoom = zoom / 0.9;
        //console.log(zoom);
        xOffset += (oldZoom * 250) - (zoom * 250);
        yOffset += (oldZoom * 250) - (zoom * 250);
    }

    function CreateLink()
    {
        //CopyEquation();
        var copyText = document.getElementById("showfunc").value;
        var myUrl = location.protocol + '//' + location.host;
        console.log(myUrl)
        myUrl += location.pathname;
        var lastChar = myUrl[myUrl.length-1]
        if(lastChar=="/")
            myUrl = myUrl.substring(0,myUrl.length-1)
        newUrl = myUrl + "?equation=" + btoa(copyText);
        // document.getElementById("link").value = newUrl;
        document.getElementById("share_link").href = "mailto:artbot@emorym.com?subject=A Cool One!&body=" + newUrl;
        return newUrl;
    }

    function CopyLink()
    {
        var newUrl = CreateLink();
        var copyText = document.getElementById("urlText");
        document.getElementById("urlText").value = newUrl;
        copyText.select();
        copyText.setSelectionRange(0, 99999);
        document.execCommand("copy");
    }

    function CopyEquation()
    {
        var copyText = document.getElementById("showfunc");
        copyText.select();
        copyText.setSelectionRange(0, 99999);
        document.execCommand("copy");
    }

    function LoadEquation()
    {
        var copyText = document.getElementById("showfunc").value;
        RegenShaders(copyText);
    }

    function LoadPalette()
    {
        var equationText = document.getElementById("showfunc").value;
        //var equationHash = equationText.hash;
        Math.seedrandom(equationText);

        var colorArrays = [
      //[0,0,0],
        [0,0,188],
        [0,0,252],
        [0,104,0],
        [0,120,0],
        [0,120,248],
        [0,136,136],
        [0,168,0],
        [0,168,68],
        [0,184,0],
        [0,232,216],
        [0,252,252],
        [0,64,88],
        [0,88,0],
        [0,88,248],
        [104,136,252],
        [104,68,252],
        [120,120,120],
        [124,124,124],
        [136,20,0],
        [148,0,132],
        [152,120,248],
        [164,228,252],
        [168,0,32],
        [168,16,0],
        [172,124,0],
        [184,184,248],
        [184,248,184],
        [184,248,216],
        [184,248,24],
        [188,188,188],
        [216,0,204],
        [216,184,248],
        [216,248,120],
        [228,0,88],
        [228,92,16],
        [240,208,176],
        [248,120,248],
        [248,120,88],
        [248,164,192],
        [248,184,0],
        [248,184,248],
        [248,216,120],
        [248,216,248],
        [248,248,248],
        [248,56,0],
        [248,88,152],
        [252,160,68],
        [252,224,168],
        [252,252,252],
        [60,188,252],
        [68,40,188],
        [80,48,0],
        [88,216,84],
        [88,248,152]
        ];

        canvas = document.getElementById("palette");
        context = canvas.getContext('2d');
        context.fillStyle = "black";
        context.fillRect(0, 0, canvas.width, canvas.height);
        imageDat = context.getImageData(0,0,canvas.width,canvas.height);
        imageData = imageDat.data;

        for(y = 0; y < 2; ++y)
        {
            for(x = 1; x < 16; ++x)
            {
                i = x+(y*16);
                j = Math.floor(Math.random() * colorArrays.length);
                col = colorArrays[j];
                //colorArrays.splice(j, 1);
                imageData[i*4] = col[0];
                imageData[(i*4)+1] = col[1];
                imageData[(i*4)+2] = col[2];
                imageData[(i*4)+3] = 255;
            }
        }

        context.putImageData(imageDat,0,0);
    }

    function LoadGL()
    {
        if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) )
        {
            document.getElementById("share_link").style.display = "block";
        }

        document.getElementById("urlText").value = "";
        glCanvas = document.getElementById("webgl");
        bufferCanvas = document.getElementById("buffer");
        bufferContext = bufferCanvas.getContext("2d");

        // touch movement - finger down, move, finger up
        // based on https://developer.mozilla.org/en-US/docs/Web/API/Touch_events
        glCanvas.addEventListener("touchstart", HandleTouchStart, false);
        glCanvas.addEventListener("touchend", HandleTouchEnd, false);
        glCanvas.addEventListener("touchcancel", HandleTouchEnd, false);
        glCanvas.addEventListener("touchmove", HandleTouchMove, false);

        // mouse movement - left click & drag
        // based on http://bencentra.com/code/2014/12/05/html5-canvas-touch-events.html
        glCanvas.addEventListener("mousedown", HandleMouseStart, false);
        window.addEventListener("mouseup", HandleMouseEnd, false);
        // glCanvas.addEventListener("mouseout", HandleMouseEnd, false);
        glCanvas.addEventListener("mousemove", HandleMouseMove, false);
        glCanvas.addEventListener("wheel", HandleMouseZoom, false);

        try {
            gl = glCanvas.getContext("experimental-webgl");
            if (!gl) { throw "x"; }
        } catch (err) {
            console.log("No WebGL!");
            throw "Your web browser does not support WebGL!";
        }
    }

    function CreatePaletteTexture0()
    {
        gl.activeTexture(gl.TEXTURE0);

        paletteCanvas = document.getElementById("palette");
        paletteTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, paletteTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, paletteCanvas);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, paletteTexture);
        gl.activeTexture(gl.TEXTURE2);
    }

    function CreateBufferTexture1()
    {
        gl.activeTexture(gl.TEXTURE1);

        // should have this in LoadGL()
        bufferCanvas = document.getElementById("buffer");
        bufferTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, bufferTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bufferCanvas);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, bufferTexture);
        gl.activeTexture(gl.TEXTURE2);
    }

    function RegenShaders(shaderText=null)
    {
        Math.seedrandom(randomSeed+seedOffset+complexity);

        var vertexShader = "attribute vec3 pos;"+
            "void main() {"+
            "	gl_Position = vec4(pos, 1.0);"+
            "}"

        if (shaderText == null)
        {
            // if we aren't loading with the Load button check the get param
            if (showFunc == null)
            {
                showFunc = findGetParameter("equation")
                if (showFunc != null)
                {
                    showFunc = atob(showFunc);
                }
            }

            // clicks on New button should always generate a new one
            // else we didn't click Load or have a get param
            if (showFunc == null || requestNew == 1)
            {
                requestNew = 0;
                showFunc = genExpr();
            }
        }
        else
            showFunc = shaderText

        document.getElementById("showfunc").value = showFunc;
        equationText = showFunc;

        CreateLink();
        LoadPalette();

        var fragmentShader = shaderTemplate.replace("<<<showFunc>>>", showFunc);
        console.log(fragmentShader);

        var prog = shaderProgram(gl, vertexShader,fragmentShader);
        gl.useProgram(prog);

        xLocc = gl.getUniformLocation(prog, "xOffset");
        yLocc = gl.getUniformLocation(prog, "yOffset");
        tLocc = gl.getUniformLocation(prog, "t");
        zoomLocc = gl.getUniformLocation(prog, "zoom");

        t = 0;
        xOffset = -250;
        yOffset = -250;
        zoom = 1;

        CreatePaletteTexture0();
        CreateBufferTexture1();

        return prog;
    }

    function RenderingSetup()
    {
        // ah yes, ERROR GREY
        gl.clearColor(0.8, 0.8, 0.8, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        var prog = RegenShaders();
        prog = RegenShaders();

        attributeSetFloats(gl, prog, "pos", 3, [
            -1, 1, 0,
            -1, -1, 0,
            1, -1, 0,
            1, 1, 0,
            -1, 1, 0
        ]);

        paletteSamplerLocation = gl.getUniformLocation(prog, "palette");
        gl.uniform1i(paletteSamplerLocation, 0);

        bufferSamplerLocation = gl.getUniformLocation(prog, "lastFrame");
        gl.uniform1i(bufferSamplerLocation, 1);

        draw();
    }

    function draw()
    {
        gl.clearColor(0.8, 0.8, 0.8, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // set shader values
        t += 0.01;
        gl.uniform1f(tLocc, t);
        gl.uniform1f(xLocc, xOffset);
        gl.uniform1f(yLocc, yOffset);
        gl.uniform1f(zoomLocc, zoom);

        // perform the drawing
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 5);

        // copy the GL canvas to the buffer canvas
        bufferContext.drawImage(glCanvas, 0, 0);

        // set the buffer texture to the contents of the buffer canvas
        gl.activeTexture(gl.TEXTURE1);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bufferCanvas);
        gl.activeTexture(gl.TEXTURE0);
        // gl.bindTexture(gl.TEXTURE_2D, bufferTexture);

        window.requestAnimationFrame(draw);
    }

    function Init()
    {
        Math.seedrandom(randomSeed+seedOffset);
        LoadGL();
        RenderingSetup();
        RegenShaders();
        draw();
    }
</script>
<script src="generator.js"></script>

<center>
    <canvas id="webgl" width="512" height="512"></canvas>
    <canvas id="buffer" width="512" height="512" style="display:none;"></canvas><br>
    <center>
        <table>
            <tr>
                <td><a onclick="seedOffset -= 1; requestNew= 1; RegenShaders();" class="button">Prev</a></td>
                <td><a href="mailto:emorym@gmail.com?subject=A Cool One!&body=" id="share_link" class="button" style="display: none;">Share with Emory</a></td>
                <td><a onclick="LoadEquation();" class="button">Load</a></td>
                <td><a onclick="CopyLink();" class="button">Copy Link</a></td>
                <td><a onclick="seedOffset += 1; requestNew= 1; RegenShaders();" class="button">Next</a></td>
            </tr>
        </table>
    </center>


    <table style="display: none;">
        <tr width="512px">
            <td><input type="button" onclick="seedOffset -= 1; requestNew= 1; RegenShaders();" value="Prev" style="width: 100%;"/></td>
            <td><input type="button" onclick="seedOffset += 1; requestNew= 1; RegenShaders();" value="Next" style="width: 100%;"/></td>
            <td><form action="mailto:artbot@emorym.com"><input type="hidden" name="link" id="link"/><input type="submit" value="Share with Emory" style="width: 100%;"/></form></td>
            <td><input type="button" onclick="CopyLink();" value="Copy Link" style="width: 100%;"/></td>
        </tr>
    </table>
    <br>
    Complexity: <input type="text" value="140" onchange="complexity=Number(this.value);"/>
    <br>
    <textarea rows="4" cols="50" id="showfunc"/></textarea><br>
    <!-- Zoom: <span id="zoom"></span><br>
    Offsets: <span id="xOffset"></span>, <span id="yOffset"></span> -->
    <input type="text" value="" id="urlText"/>
    <center><canvas id="palette" width="16" height="2" style="width:16px; height:2px;"></canvas></center><br>

    WHATWHATWHAT
</center>
</body>
</html>